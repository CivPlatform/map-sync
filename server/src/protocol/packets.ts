import { BufReader } from "./BufReader";
import { Packets } from "./index";
import { BufWriter } from "./BufWriter";
import { RegionPos, RegionTimestamp } from "./structs";

/**
 * The Minecraft client should send this packet IMMEDIATELY upon a successful
 * connection to the MapSync server.
 */
export class HandshakePacket {
    public readonly type: string = Packets[Packets.Handshake];

    /**
     * @param modVersion The MapSync version (effectively the protocol version)
     * @param mojangName The client's Mojang username (not their email)
     * @param gameAddress The server-address for the Minecraft server they're
     *                    connected to.
     * @param world The dimension the client is in.
     */
    public constructor(
        public readonly modVersion: string,
        public readonly mojangName: string,
        public readonly gameAddress: string,
        public readonly world: string
    ) {}

    public static decode(reader: BufReader): HandshakePacket {
        return new HandshakePacket(
            reader.readString(),
            reader.readString(),
            reader.readString(),
            reader.readString()
        );
    }
}

/**
 * This is sent back to the client after the Handshake.
 */
export class EncryptionRequestPacket {
    public readonly type = Packets[Packets.EncryptionRequest];

    /**
     * @param publicKey This server's public key.
     * @param verifyToken A transaction ID of four randomly generated bytes
     */
    public constructor(
        public readonly publicKey: Buffer,
        public readonly verifyToken: Buffer
    ) {}

    public encode(writer: BufWriter) {
        writer.writeBufWithLen(this.publicKey);
        writer.writeBufWithLen(this.verifyToken);
    }
}

/**
 * Once this packet is received, the client should be considered fully verified
 * and thus can share map information.
 */
export class EncryptionResponsePacket {
    public readonly type: string = Packets[Packets.EncryptionResponse];

    /**
     * @param sharedSecret A 16-bit secret created and shared by the client
     * @param verifyToken The verifyToken sent in the EncyrptionRequest which
     *                    has been encrypted with the server's public key.
     */
    public constructor(
        public readonly sharedSecret: Buffer,
        public readonly verifyToken: Buffer
    ) {}

    public static decode(reader: BufReader): EncryptionResponsePacket {
        return new EncryptionResponsePacket(
            reader.readBufWithLen(),
            reader.readBufWithLen()
        );
    }
}

/**
 * This is the first packet send to the client post-encryption setup. This
 * packet is used to inform the client when each region was last updated, which
 * the client can use to request newer regions from MapSync.
 */
export class RegionTimestampsPacket {
    public readonly type = Packets[Packets.RegionTimestamps];

    public constructor(
        public readonly world: string,
        public readonly regions: RegionTimestamp[]
    ) { }

    public encode(writer: BufWriter) {
        writer.writeString(this.world);
        writer.writeInt16(this.regions.length);
        if (this.regions.length > 32767) { // TODO: Remove this if it's not an issue
            console.error("Attempting to send region timestamps, but the regions surpass the maximum value for a signed-short length!");
        }
        for (const region of this.regions) {
            writer.writeInt16(region.x);
            writer.writeInt16(region.z);
            writer.writeInt64(region.ts);
        }
    }
}

/**
 * This is a response to the RegionTimestampsPacket: the client is requesting
 * to be updated on regions that are outdated for it.
 */
export class RegionCatchupRequestPacket {
    public readonly type: string = Packets[Packets.RegionCatchup];

    public constructor(
        public readonly world: string,
        public readonly regions: RegionPos[]
    ) {}

    public static decode(reader: BufReader): RegionCatchupRequestPacket {
        return new RegionCatchupRequestPacket(
            reader.readString(),
            (function (length) {
                const regions: RegionPos[] = new Array(length);
                for (let i = 0; i < length; i++) {
                    regions[i] = {
                        x: reader.readInt16(),
                        z: reader.readInt16()
                    };
                }
                return regions;
            })(reader.readInt16())
        );
    }
}
